<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Flappy Physics Pro</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial Black', sans-serif;
            overflow: hidden;
            touch-action: manipulation; /* Mobile tap fix */
        }
        canvas {
            border: 4px solid #fff;
            background-color: #70c5ce;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            display: block;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="320" height="480"></canvas>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // --- VARIABLES ---
    let frames = 0;
    const DEGREE = Math.PI / 180;

    // --- GAME STATE ---
    const state = {
        current: 0,
        getReady: 0,
        game: 1,
        over: 2
    };

    // --- CONTROLS ---
    function action() {
        switch(state.current) {
            case state.getReady:
                state.current = state.game;
                break;
            case state.game:
                bird.flap();
                break;
            case state.over:
                resetGame();
                break;
        }
    }
    
    document.addEventListener("mousedown", action);
    document.addEventListener("keydown", (e) => {
        if(e.code === "Space") action();
    });

    // --- BIRD OBJECT (With Physics & Rotation) ---
    const bird = {
        x: 50,
        y: 150,
        w: 34,
        h: 24,
        radius: 12,
        
        speed: 0,
        gravity: 0.25,      // Thoda bhaari gravity
        jump: 4.6,          // Sharp jump
        rotation: 0,        // Angle of bird
        
        draw: function() {
            ctx.save(); // Save canvas state
            ctx.translate(this.x, this.y); // Move origin to bird center
            ctx.rotate(this.rotation);     // Rotate canvas based on physics

            // Bird Body (Rectangle for pixel art look via code)
            ctx.fillStyle = "#FFD700"; 
            ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            
            // Bird Outline
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#000";
            ctx.strokeRect(-this.w/2, -this.h/2, this.w, this.h);

            // Bird Eye
            ctx.fillStyle = "#FFF";
            ctx.fillRect(2, -8, 10, 10);
            ctx.strokeRect(2, -8, 10, 10);
            
            // Pupil
            ctx.fillStyle = "#000";
            ctx.fillRect(8, -5, 2, 2);

            // Beak
            ctx.fillStyle = "#FF4500"; // Orange
            ctx.fillRect(6, 4, 14, 8);
            ctx.strokeRect(6, 4, 14, 8);

            ctx.restore(); // Restore canvas state for other objects
        },
        
        flap: function() {
            this.speed = -this.jump;
        },
        
        update: function() {
            // Period (Slow flap animation in Get Ready state)
            if (state.current == state.getReady) {
                this.y = 150 - 10 * Math.cos(frames * 0.1); // Bobbing effect
                this.rotation = 0;
            } else {
                this.speed += this.gravity;
                this.y += this.speed;

                // --- REALISTIC ROTATION LOGIC ---
                // If moving up, rotate up instantly
                if(this.speed < this.jump/2) {
                    this.rotation = -25 * DEGREE;
                } 
                // If falling, rotate down gradually
                else {
                    this.rotation += 5 * DEGREE;
                    // Cap rotation at 90 degrees
                    if(this.rotation > 90 * DEGREE) {
                        this.rotation = 90 * DEGREE; 
                    }
                }

                // Floor Collision
                if (this.y + this.h/2 >= canvas.height - fg.h) {
                    this.y = canvas.height - fg.h - this.h/2;
                    if(state.current == state.game) {
                        state.current = state.over;
                    }
                }
            }
        }
    };

    // --- BACKGROUND ---
    const bg = {
        draw: function() {
            ctx.fillStyle = "#70c5ce";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Buildings (Cityscape)
            ctx.fillStyle = "#a3e8f0";
            ctx.fillRect(0, 300, 100, 200);
            ctx.fillRect(110, 350, 50, 150);
            ctx.fillRect(170, 280, 80, 220);
            ctx.fillRect(260, 320, 60, 180);
        }
    };

    // --- FOREGROUND ---
    const fg = {
        h: 112,
        x: 0,
        dx: 2,
        draw: function() {
            // Ground Pattern
            ctx.fillStyle = "#ded895";
            ctx.fillRect(0, canvas.height - this.h, canvas.width, this.h);
            
            // Top Green Stripe
            ctx.fillStyle = "#73bf2e";
            ctx.fillRect(0, canvas.height - this.h, canvas.width, 15);
            ctx.strokeStyle = "#558c22";
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - this.h + 15);
            ctx.lineTo(canvas.width, canvas.height - this.h + 15);
            ctx.stroke();
        },
        update: function() {
            if (state.current == state.game) {
                // Moving ground effect
                this.x = (this.x - this.dx) % 20; 
            }
        }
    };

    // --- PIPES ---
    const pipes = {
        position: [],
        w: 52,
        h: 400,
        gap: 100, // Challenge gap
        dx: 2,
        
        draw: function() {
            for (let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                let topY = p.y;
                let bottomY = p.y + this.h + this.gap;
                
                // Pipe Main Body
                ctx.fillStyle = "#73bf2e";
                ctx.fillRect(p.x, topY, this.w, this.h);
                ctx.fillRect(p.x, bottomY, this.w, this.h);
                
                // Pipe Outlines
                ctx.strokeStyle = "#555";
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x, topY, this.w, this.h);
                ctx.strokeRect(p.x, bottomY, this.w, this.h);

                // Pipe Cap (The wider part)
                ctx.fillStyle = "#73bf2e";
                ctx.fillRect(p.x - 2, topY + this.h - 20, this.w + 4, 20); // Top cap
                ctx.strokeRect(p.x - 2, topY + this.h - 20, this.w + 4, 20);
                
                ctx.fillRect(p.x - 2, bottomY, this.w + 4, 20); // Bottom cap
                ctx.strokeRect(p.x - 2, bottomY, this.w + 4, 20);
            }
        },
        
        update: function() {
            if (state.current !== state.game) return;
            
            if (frames % 120 == 0) { // Spacing between pipes
                this.position.push({
                    x: canvas.width,
                    y: -150 * (Math.random() + 1)
                });
            }
            
            for (let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                p.x -= this.dx;

                // Collision Logic
                // 1. Hit Top Pipe
                if (bird.x + bird.w/2 > p.x && bird.x - bird.w/2 < p.x + this.w && 
                    bird.y - bird.h/2 < p.y + this.h) {
                    state.current = state.over;
                }
                // 2. Hit Bottom Pipe
                if (bird.x + bird.w/2 > p.x && bird.x - bird.w/2 < p.x + this.w && 
                    bird.y + bird.h/2 > p.y + this.h + this.gap) {
                    state.current = state.over;
                }

                if (p.x + this.w <= 0) {
                    this.position.shift();
                    score.value += 1;
                    score.best = Math.max(score.value, score.best);
                }
            }
        }
    };

    // --- SCORE ---
    const score = {
        best: localStorage.getItem('flappy_best') || 0,
        value: 0,
        
        draw: function() {
            ctx.fillStyle = "#FFF";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;

            if (state.current == state.game) {
                ctx.font = "50px Impact";
                ctx.fillText(this.value, canvas.width / 2 - 15, 80);
                ctx.strokeText(this.value, canvas.width / 2 - 15, 80);
            } else if (state.current == state.over) {
                // Game Over Screen
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.fillRect(40, 100, 240, 200);
                
                ctx.fillStyle = "#000";
                ctx.font = "30px Impact";
                ctx.fillText("SCORE", 115, 140);
                ctx.font = "40px Impact";
                ctx.fillText(this.value, 145, 185);
                
                ctx.font = "20px Impact";
                ctx.fillStyle = "#e8802e";
                ctx.fillText("BEST: " + this.best, 120, 230);
                localStorage.setItem('flappy_best', this.best);

                ctx.fillStyle = "#000";
                ctx.font = "20px Arial";
                ctx.fillText("Tap to Restart", 95, 280);
            } else if (state.current == state.getReady) {
                ctx.fillStyle = "#000";
                ctx.font = "30px Impact";
                ctx.fillText("Get Ready!", 90, 200);
                ctx.font = "15px Arial";
                ctx.fillText("Tap or Space", 115, 230);
            }
        }
    };

    function resetGame() {
        bird.speed = 0;
        bird.rotation = 0;
        pipes.position = [];
        score.value = 0;
        frames = 0;
        state.current = state.getReady;
    }

    function draw() {
        bg.draw();
        pipes.draw();
        fg.draw();
        bird.draw();
        score.draw();
    }

    function update() {
        bird.update();
        fg.update();
        pipes.update();
    }

    function loop() {
        update();
        draw();
        frames++;
        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>